import 'json' as json
import 'object_factory' as objfactory
import 'light' as light
import 'vector3D' as vector
import 'ray' as ray

var WIDTH = 800
var HEIGHT = 400
var SAMPLES_PER_PIXEL = 8
var WHITE = vector.Vector3D(1.0, 1.0, 1.0)
var LIGHT_BLUE = vector.Vector3D(0.5, 0.7, 1.0)

var REFLECTED_LIGHT_SCALAR = 0.1
var DIFFUSE_LIGHT_SCALAR = 0.9
var AMBIENT_LIGHT_SCALAR = 0.1


class Scene {
    init() {
        var scene = json.parse_from_file('scene.json')
        self.lights = []
        self.objects = []
        foreach (var lightHash in scene["lights"]) {
            var licht = light.Light(lightHash)
            self.lights.push(licht)
        }
        foreach (var obj in scene["objects"]) {
            self.objects.push(objfactory.createObject(obj))
        }
    }

    _find_intersection(incident_ray) {
        var closest = nil
        foreach (var obj in self.objects) {
            var result = obj.intersect(incident_ray)
            if (!result.nil?())
            {
                if (closest.nil?() || result.t < closest.t) {
                    closest = result
                }
            }
        }
        return closest
    }

    _background_colour(ray) {
        var height = ray.direction.normalise().y
        var t = 0.5 * height + 1
        var colour = WHITE * (1 - t) + LIGHT_BLUE * t
        return vector.Vector3D(colour.x, colour.y, colour.z)
    }

    trace_ray(incident, depth = 0) {
        if (depth == 3) {
            return self._background_colour(incident)
        }

        var intersection = self._find_intersection(incident)
        if (!intersection.nil?()) {
            var colour = intersection.object.colour * AMBIENT_LIGHT_SCALAR

            foreach (var light in self.lights) {
                var lightVector = (light.position - intersection.position).normalise()
                var cosTheta = Number.max(intersection.normal.dot(lightVector), 0)
                if (cosTheta > 0) {
                    colour += intersection.object.colour * cosTheta * DIFFUSE_LIGHT_SCALAR
                }

                var viewVector = (incident.position - intersection.position).normalise()
                var reflection_angle = viewVector.dot(intersection.normal)
                var reflection = ((intersection.normal - lightVector) * (2 * reflection_angle)).normalise()
                var specular = Number.max(reflection.dot(viewVector), 0).power(0.3 * intersection.object.shininess)
                colour += light.colour * specular

                # move it the tiniest fraction away from the object, so we don't re-collide with it.
                var reflection_position = intersection.position + (reflection * vector.EPSILON)
                colour += self.trace_ray(ray.Ray(reflection_position, reflection), depth + 1) * REFLECTED_LIGHT_SCALAR
            }

            return vector.Vector3D(
                colour.x,
                colour.y,
                colour.z)
        }

        return self._background_colour(incident)
    }

    render() {
        var image = Image(WIDTH, HEIGHT)
        var origin = vector.Vector3D()
        var horizontal = vector.Vector3D(4, 0, 0)
        var vertical = vector.Vector3D(0, 2, 0)
        var lower_left_corner = vector.Vector3D(-2, -1, -1)

        for (var y = 0; y < HEIGHT; y+=1) {
            for (var x = 0; x < WIDTH; x+=1) {
                var colour = vector.Vector3D(0, 0, 0)
                for (var s = 0; s < SAMPLES_PER_PIXEL; s+=1) {
                    var pix_x = (x + Number.random() - 0.5)
                    var pix_y = (y + Number.random() - 0.5)
                    var u = horizontal * (pix_x / WIDTH)
                    var v = vertical * (pix_y / HEIGHT)
                    var incident = ray.Ray(origin, lower_left_corner + u + v)
                    colour += self.trace_ray(incident)
                }
                colour /= SAMPLES_PER_PIXEL
                image.set_pixel(x, y, colour.r(), colour.g(), colour.b())
            }
        }
        return image
    }
}